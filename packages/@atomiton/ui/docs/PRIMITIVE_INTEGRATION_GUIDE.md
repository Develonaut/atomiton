# Primitive Integration Guide for Atomiton UI Library

## Overview

This guide establishes the pattern for integrating shadcn/ui primitives into our UI component library. We use shadcn as our primitive layer while maintaining a clear separation of concerns between base functionality and business logic.

## Architecture Pattern

### Three-Layer Architecture

```
┌─────────────────────────────────────┐
│     Business Components Layer       │  ← Our components with business logic
│     (packages/@atomiton/ui)         │     and Atomiton-specific features
└─────────────────────────────────────┘
                  ↓
┌─────────────────────────────────────┐
│      Primitive Wrapper Layer        │  ← Our styled wrapper around primitives
│    (src/components/[Component])     │     with custom variants and props
└─────────────────────────────────────┘
                  ↓
┌─────────────────────────────────────┐
│       shadcn Primitive Layer        │  ← Unmodified shadcn components
│        (src/primitives/*.tsx)       │     providing base functionality
└─────────────────────────────────────┘
```

## Implementation Strategy

### 1. Adding a New shadcn Primitive

When adding a new shadcn component:

```bash
# Install the shadcn component to primitives directory
npx shadcn-ui@latest add button --path=src/primitives
```

**Key Rule**: NEVER modify the shadcn primitive directly. It should remain as-is for:

- Easy updates from shadcn
- Clear separation of concerns
- Predictable base behavior

### 2. Creating the Wrapper Component

Create a wrapper component that extends the primitive:

```typescript
// src/components/Button/Button.tsx
import { Button as ButtonPrimitive } from "@/primitives";
import { styled } from "@/system/styled";
import { buttonStyles } from "./Button.styles";
import resolveButtonProps from "./Button.resolver";
import type { ButtonProps } from "./Button.types";

const ButtonRoot = styled(ButtonPrimitive, {
  name: "Button",
  props: resolveButtonProps,
  styles: buttonStyles,
});

function Button(props: ButtonProps) {
  // Add business logic here
  return <ButtonRoot {...props} />;
}
```

### 3. Handling Styles

#### What to Keep vs. Override

**Keep in Primitive:**

- Base structural styles (flex, display, position)
- Accessibility styles (focus rings, disabled states)
- Core interaction styles (hover, active)
- Radix UI integration styles

**Override in Wrapper:**

- Brand-specific colors and gradients
- Custom spacing and sizing
- Animation and transitions
- Business-specific variants

#### Style Resolution Strategy

```typescript
// Button.styles.ts
export const buttonStyles = cva(
  [
    // Override base styles while preserving structure
    "relative",
    "inline-flex",
    "justify-center",
    "items-center",
    // Add custom styles
    "rounded-xl", // Override shadcn's rounded-md
  ],
  {
    variants: {
      // Define Atomiton-specific variants
      variant: {
        primary: [...],
        secondary: [...],
        orange: [...], // Custom variant not in shadcn
      },
      size: {
        // Override shadcn sizes with our design system
        sm: ["h-9", "px-5"],
        md: ["h-10", "px-6"],
        lg: ["h-12", "px-8"],
      },
    },
  },
);
```

### 4. Props Resolution

Use a resolver to map between business props and primitive props:

```typescript
// Button.resolver.ts
export default function resolveButtonProps(props: ButtonProps) {
  return {
    ...props,
    // Map our variant names to shadcn if needed
    variant: mapVariantToShadcn(props.variant),
    // Add computed props
    disabled: props.disabled || props.loading,
    // Remove business-only props
    loading: undefined,
  };
}
```

## Best Practices

### DO's

1. **DO** wrap shadcn primitives with your own components
2. **DO** use CVA for variant management in both layers
3. **DO** maintain the primitive's accessibility features
4. **DO** export both the wrapper and primitive (if needed)
5. **DO** document which shadcn version each primitive uses
6. **DO** test that primitive updates don't break wrappers

### DON'Ts

1. **DON'T** modify shadcn primitives directly
2. **DON'T** duplicate all shadcn styles in your wrapper
3. **DON'T** remove accessibility features from primitives
4. **DON'T** mix business logic in primitives
5. **DON'T** create deep inheritance chains

## Example: Complete Button Implementation

### 1. Primitive (Unmodified shadcn)

```typescript
// src/primitives/button.tsx
// This file is generated by shadcn - DO NOT MODIFY
import * as React from "react";
import { Slot } from "@radix-ui/react-slot";
import { cva, type VariantProps } from "class-variance-authority";
import { cn } from "@/utils/cn";

const buttonVariants = cva(
  "inline-flex items-center justify-center...",
  // ... shadcn default implementation
);
```

### 2. Wrapper Component

```typescript
// src/components/Button/index.tsx
export { default as Button } from "./Button";
export type { ButtonProps } from "./Button.types";
```

### 3. Component Implementation

```typescript
// src/components/Button/Button.tsx
import React from "react";
import { Button as ButtonPrimitive } from "@/primitives";
import { styled } from "@/system/styled";
import { buttonStyles } from "./Button.styles";
import type { ButtonProps } from "./Button.types";

const ButtonRoot = styled(ButtonPrimitive, {
  name: "Button",
  styles: buttonStyles,
});

function Button({ loading, ...props }: ButtonProps) {
  return (
    <ButtonRoot {...props} disabled={props.disabled || loading}>
      {loading ? <Spinner /> : props.children}
    </ButtonRoot>
  );
}
```

### 4. Custom Styles

```typescript
// src/components/Button/Button.styles.ts
export const buttonStyles = cva(
  ["rounded-xl"], // Override specific styles
  {
    variants: {
      // Custom variants for Atomiton
    },
  },
);
```

## Migration Checklist

When migrating an existing component to use shadcn:

- [ ] Install shadcn primitive to `src/primitives/`
- [ ] Create wrapper component in `src/components/[Name]/`
- [ ] Identify styles to keep vs. override
- [ ] Create style variants using CVA
- [ ] Add props resolver if needed
- [ ] Test accessibility features still work
- [ ] Document any breaking changes
- [ ] Update component exports

## Updating shadcn Primitives

When shadcn releases updates:

1. Review the changelog for breaking changes
2. Update the primitive file only
3. Test all wrapper components still work
4. Update resolver if new props added
5. Document the update version

## FAQ

**Q: Should we edit the shadcn primitive's styles directly?**
A: No. Keep primitives unmodified for maintainability.

**Q: Where do custom variants go?**
A: In your wrapper component's styles file.

**Q: How do we handle conflicting styles?**
A: CSS specificity and CVA's className merging handle this. Your wrapper styles override primitive styles.

**Q: Can we use shadcn's variants in our wrapper?**
A: Yes, pass them through or map them in your resolver.

**Q: What about shadcn's cn() utility?**
A: Use it in primitives, but prefer CVA in wrappers for consistency.
