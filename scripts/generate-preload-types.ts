#!/usr/bin/env tsx
/**
 * Auto-generates preload types from RPC source of truth
 * Run: pnpm generate:preload-types
 *
 * This ensures preload types never drift from RPC types.
 * Preload is security-boxed and cannot import packages, so we generate a copy.
 */

import * as fs from "fs";
import * as path from "path";

const RPC_TYPES_PATH = path.join(
  __dirname,
  "../packages/@atomiton/rpc/src/shared/types.ts",
);
const PRELOAD_TYPES_PATH = path.join(
  __dirname,
  "../apps/desktop/src/preload/preload.d.ts",
);

function extractTypeDefinition(content: string, typeName: string): string {
  // Find the export statement and capture everything until the closing brace
  const lines = content.split("\n");
  let inType = false;
  let braceCount = 0;
  let typeLines: string[] = [];
  let commentLines: string[] = [];

  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];

    // Capture JSDoc comments before the type
    if (!inType && line.trim().startsWith("/**")) {
      commentLines = [line];
      continue;
    }

    if (commentLines.length > 0 && !inType) {
      commentLines.push(line);
      if (line.trim().endsWith("*/")) {
        // Check if next line is our type
        continue;
      }
    }

    // Find the type definition start
    if (!inType && line.includes(`export type ${typeName}`)) {
      inType = true;
      // Remove 'export ' prefix
      const cleanLine = line.replace(/^(\s*)export /, "$1");
      typeLines.push(cleanLine);
      braceCount += (line.match(/{/g) || []).length;
      braceCount -= (line.match(/}/g) || []).length;

      if (braceCount === 0 && line.includes(";")) {
        break; // Single-line type
      }
      continue;
    }

    if (inType) {
      typeLines.push(line);
      braceCount += (line.match(/{/g) || []).length;
      braceCount -= (line.match(/}/g) || []).length;

      if (braceCount === 0 && line.includes(";")) {
        break; // Type complete
      }
    }
  }

  if (typeLines.length === 0) {
    throw new Error(`Could not find ${typeName} type definition in RPC types`);
  }

  // Filter out comment lines that contain export type (avoid duplicates)
  const cleanComments = commentLines.filter(
    (line) => !line.includes("export type"),
  );

  // Combine comments and type
  return [...cleanComments, ...typeLines].join("\n");
}

function generatePreloadTypes(): void {
  console.log("🔄 Generating preload types from RPC source...\n");

  // Read RPC types
  const rpcContent = fs.readFileSync(RPC_TYPES_PATH, "utf-8");

  // Extract type definitions
  const atomitonBridgeType = extractTypeDefinition(
    rpcContent,
    "AtomitonBridge",
  );
  const bridgeResponseType = extractTypeDefinition(
    rpcContent,
    "AtomitonBridgeResponse",
  );
  const rpcErrorType = extractTypeDefinition(rpcContent, "RPCError");

  // Generate preload file
  const preloadContent = `/**
 * ═══════════════════════════════════════════════════════════════════════════
 * ⚠️  WARNING: AUTO-GENERATED FILE - DO NOT EDIT MANUALLY  ⚠️
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * This file is automatically generated from the RPC package source of truth.
 *
 * 🔒 Source of Truth:
 *    packages/@atomiton/rpc/src/shared/types.ts
 *
 * 🔄 To Update Types:
 *    pnpm generate:preload-types
 *
 * 🤖 Auto-Generation:
 *    - Pre-commit hook automatically regenerates when RPC types change
 *    - Lefthook runs: generate → validate → stage
 *    - CI validates types are in sync
 *
 * ❓ Why Auto-Generated?
 *    The preload script is security-boxed by Electron and cannot import
 *    from npm packages. We maintain type safety by auto-generating a copy
 *    from the RPC source of truth.
 *
 * 🚫 DO NOT:
 *    - Edit this file manually
 *    - Add custom types here
 *    - Modify type definitions
 *    - Bypass the generation script
 *
 * ✅ TO ADD NEW TYPES:
 *    1. Add to: packages/@atomiton/rpc/src/shared/types.ts
 *    2. Run: pnpm generate:preload-types
 *    3. Commit both files
 *
 * ═══════════════════════════════════════════════════════════════════════════
 */

import type { ElectronAPI } from "@electron-toolkit/preload";

// Extended ElectronAPI
type ExtendedElectronAPI = ElectronAPI;

// ============================================================================
// AUTO-GENERATED TYPES FROM RPC PACKAGE
// ============================================================================

${atomitonBridgeType}

${bridgeResponseType}

${rpcErrorType}

declare global {
  // eslint-disable-next-line @typescript-eslint/consistent-type-definitions
  interface Window {
    electron: ExtendedElectronAPI;
    atomitonBridge: AtomitonBridge;
  }
}

export {};
`;

  // Write to preload file
  fs.writeFileSync(PRELOAD_TYPES_PATH, preloadContent, "utf-8");

  console.log("✅ Preload types generated successfully!\n");
  console.log("Source:", RPC_TYPES_PATH);
  console.log("Output:", PRELOAD_TYPES_PATH);
  console.log("\nTypes generated:");
  console.log("  - AtomitonBridge");
  console.log("  - AtomitonBridgeResponse");
  console.log("  - RPCError");
}

// Run generation
try {
  generatePreloadTypes();
} catch (error) {
  console.error("\n❌ Generation failed:", error);
  process.exit(1);
}
